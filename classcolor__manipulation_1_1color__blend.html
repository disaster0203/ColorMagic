<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ColorMagic: color_manipulation::color_blend Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ColorMagic
   </div>
   <div id="projectbrief">C++ Library that allows manipulation and conversion of colors.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecolor__manipulation.html">color_manipulation</a></li><li class="navelem"><a class="el" href="classcolor__manipulation_1_1color__blend.html">color_blend</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classcolor__manipulation_1_1color__blend-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">color_manipulation::color_blend Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Static class for color blending operations.  
 <a href="classcolor__manipulation_1_1color__blend.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="color__blend_8h_source.html">color_blend.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for color_manipulation::color_blend:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcolor__manipulation_1_1color__blend.png" usemap="#color_5Fmanipulation::color_5Fblend_map" alt=""/>
  <map id="color_5Fmanipulation::color_5Fblend_map" name="color_manipulation::color_blend_map">
<area href="classcolor__manipulation_1_1base__color__blend.html" title="Base class for porter duff and color blend operations. " alt="color_manipulation::base_color_blend" shape="rect" coords="0,0,225,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af44f0276259e2fdbe06c0a469e2302de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#af44f0276259e2fdbe06c0a469e2302de">normal</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:af44f0276259e2fdbe06c0a469e2302de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does not do any special blending.  <a href="#af44f0276259e2fdbe06c0a469e2302de">More...</a><br /></td></tr>
<tr class="separator:af44f0276259e2fdbe06c0a469e2302de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ec14a652c1fef4e2e2429aa37b159"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a919ec14a652c1fef4e2e2429aa37b159">dissolve</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a919ec14a652c1fef4e2e2429aa37b159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does dissolve blending.  <a href="#a919ec14a652c1fef4e2e2429aa37b159">More...</a><br /></td></tr>
<tr class="separator:a919ec14a652c1fef4e2e2429aa37b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9304fb70babc112300659602dbe1ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a5f9304fb70babc112300659602dbe1ef">multiply</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a5f9304fb70babc112300659602dbe1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does multiply blending.  <a href="#a5f9304fb70babc112300659602dbe1ef">More...</a><br /></td></tr>
<tr class="separator:a5f9304fb70babc112300659602dbe1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07bf8b0fd82a59a8353f3828892f2fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ad07bf8b0fd82a59a8353f3828892f2fe">screen</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ad07bf8b0fd82a59a8353f3828892f2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does screen blending.  <a href="#ad07bf8b0fd82a59a8353f3828892f2fe">More...</a><br /></td></tr>
<tr class="separator:ad07bf8b0fd82a59a8353f3828892f2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa877bf0c850872e3128f6c479e888918"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#aa877bf0c850872e3128f6c479e888918">overlay</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:aa877bf0c850872e3128f6c479e888918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does overlay blending.  <a href="#aa877bf0c850872e3128f6c479e888918">More...</a><br /></td></tr>
<tr class="separator:aa877bf0c850872e3128f6c479e888918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd9bda0bf9739c66805d50a76284840"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a6bd9bda0bf9739c66805d50a76284840">darken</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a6bd9bda0bf9739c66805d50a76284840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does darken blending.  <a href="#a6bd9bda0bf9739c66805d50a76284840">More...</a><br /></td></tr>
<tr class="separator:a6bd9bda0bf9739c66805d50a76284840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b3c39092194bcc71e30d73efa939b2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#aa4b3c39092194bcc71e30d73efa939b2">lighten</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:aa4b3c39092194bcc71e30d73efa939b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does lighten blending.  <a href="#aa4b3c39092194bcc71e30d73efa939b2">More...</a><br /></td></tr>
<tr class="separator:aa4b3c39092194bcc71e30d73efa939b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8e94f8b4d42d595d7af4d780dee1a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#aae8e94f8b4d42d595d7af4d780dee1a0">color_dodge</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:aae8e94f8b4d42d595d7af4d780dee1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does color-dodge blending.  <a href="#aae8e94f8b4d42d595d7af4d780dee1a0">More...</a><br /></td></tr>
<tr class="separator:aae8e94f8b4d42d595d7af4d780dee1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac505037b69bd0b7e09b74006cfbdaed4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ac505037b69bd0b7e09b74006cfbdaed4">linear_dodge</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ac505037b69bd0b7e09b74006cfbdaed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does linear-dodge blending.  <a href="#ac505037b69bd0b7e09b74006cfbdaed4">More...</a><br /></td></tr>
<tr class="separator:ac505037b69bd0b7e09b74006cfbdaed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e0177b913c296017f3db2719dc1f77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a15e0177b913c296017f3db2719dc1f77">color_burn</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a15e0177b913c296017f3db2719dc1f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does color-burn blending.  <a href="#a15e0177b913c296017f3db2719dc1f77">More...</a><br /></td></tr>
<tr class="separator:a15e0177b913c296017f3db2719dc1f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6078f999bd634e3e0db79b4af441eea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#af6078f999bd634e3e0db79b4af441eea">linear_burn</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:af6078f999bd634e3e0db79b4af441eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does linear-burn blending.  <a href="#af6078f999bd634e3e0db79b4af441eea">More...</a><br /></td></tr>
<tr class="separator:af6078f999bd634e3e0db79b4af441eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e4a6dd31d114a086397053956716b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ab2e4a6dd31d114a086397053956716b0">hard_light</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ab2e4a6dd31d114a086397053956716b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does hard-light blending.  <a href="#ab2e4a6dd31d114a086397053956716b0">More...</a><br /></td></tr>
<tr class="separator:ab2e4a6dd31d114a086397053956716b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc528425b9f8038d86d38b3eb2e4f2d5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#acc528425b9f8038d86d38b3eb2e4f2d5">soft_light</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:acc528425b9f8038d86d38b3eb2e4f2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does soft-light blending.  <a href="#acc528425b9f8038d86d38b3eb2e4f2d5">More...</a><br /></td></tr>
<tr class="separator:acc528425b9f8038d86d38b3eb2e4f2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c13bc67f915a7824e9a324a759cd7d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a5c13bc67f915a7824e9a324a759cd7d8">vivid_light</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a5c13bc67f915a7824e9a324a759cd7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does vivid light blending.  <a href="#a5c13bc67f915a7824e9a324a759cd7d8">More...</a><br /></td></tr>
<tr class="separator:a5c13bc67f915a7824e9a324a759cd7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dfd7cd6be99fd36dcc8d6ce1b7090d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ab8dfd7cd6be99fd36dcc8d6ce1b7090d">linear_light</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ab8dfd7cd6be99fd36dcc8d6ce1b7090d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does linear-light blending.  <a href="#ab8dfd7cd6be99fd36dcc8d6ce1b7090d">More...</a><br /></td></tr>
<tr class="separator:ab8dfd7cd6be99fd36dcc8d6ce1b7090d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d505a4a31fca426862df5738c87fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#adc3d505a4a31fca426862df5738c87fc">pin_light</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:adc3d505a4a31fca426862df5738c87fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does pin-light blending.  <a href="#adc3d505a4a31fca426862df5738c87fc">More...</a><br /></td></tr>
<tr class="separator:adc3d505a4a31fca426862df5738c87fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d581a4515405f43019fe363308e2cc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a6d581a4515405f43019fe363308e2cc8">hard_mix</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a6d581a4515405f43019fe363308e2cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does hard-mix blending.  <a href="#a6d581a4515405f43019fe363308e2cc8">More...</a><br /></td></tr>
<tr class="separator:a6d581a4515405f43019fe363308e2cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe333470ff1c136c26490ad83efa5365"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#abe333470ff1c136c26490ad83efa5365">difference</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:abe333470ff1c136c26490ad83efa5365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does difference blending.  <a href="#abe333470ff1c136c26490ad83efa5365">More...</a><br /></td></tr>
<tr class="separator:abe333470ff1c136c26490ad83efa5365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d70c77cd299b53b76b47436b3bb5196"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a3d70c77cd299b53b76b47436b3bb5196">subtract</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a3d70c77cd299b53b76b47436b3bb5196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does subtract blending.  <a href="#a3d70c77cd299b53b76b47436b3bb5196">More...</a><br /></td></tr>
<tr class="separator:a3d70c77cd299b53b76b47436b3bb5196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ac01e6d28cbfdcf26e801df9e6610c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a46ac01e6d28cbfdcf26e801df9e6610c">divide</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a46ac01e6d28cbfdcf26e801df9e6610c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does divide blending.  <a href="#a46ac01e6d28cbfdcf26e801df9e6610c">More...</a><br /></td></tr>
<tr class="separator:a46ac01e6d28cbfdcf26e801df9e6610c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ad5bc17a16d0e73ef02a4d2306f22a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ab2ad5bc17a16d0e73ef02a4d2306f22a">plus_lighter</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ab2ad5bc17a16d0e73ef02a4d2306f22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does plus-lighter blending.  <a href="#ab2ad5bc17a16d0e73ef02a4d2306f22a">More...</a><br /></td></tr>
<tr class="separator:ab2ad5bc17a16d0e73ef02a4d2306f22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db631406f014046a89d9c83553847d5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a3db631406f014046a89d9c83553847d5">plus_darker</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a3db631406f014046a89d9c83553847d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does plus-darker blending.  <a href="#a3db631406f014046a89d9c83553847d5">More...</a><br /></td></tr>
<tr class="separator:a3db631406f014046a89d9c83553847d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589516c17e3c9afc997f1307370792c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a589516c17e3c9afc997f1307370792c5">exclusion</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a589516c17e3c9afc997f1307370792c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does exclusion blending.  <a href="#a589516c17e3c9afc997f1307370792c5">More...</a><br /></td></tr>
<tr class="separator:a589516c17e3c9afc997f1307370792c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaff4ee01b1851b33d7e2b07ea3899d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a1eaff4ee01b1851b33d7e2b07ea3899d">custom_componentwise_blend</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region, bool use_destination_region, std::function&lt; float(float, float)&gt; blend_function)</td></tr>
<tr class="memdesc:a1eaff4ee01b1851b33d7e2b07ea3899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does custom componentwise blending.  <a href="#a1eaff4ee01b1851b33d7e2b07ea3899d">More...</a><br /></td></tr>
<tr class="separator:a1eaff4ee01b1851b33d7e2b07ea3899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1f8af32648db0e032532bbd959a554"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a1e1f8af32648db0e032532bbd959a554">hue</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a1e1f8af32648db0e032532bbd959a554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does hue blending.  <a href="#a1e1f8af32648db0e032532bbd959a554">More...</a><br /></td></tr>
<tr class="separator:a1e1f8af32648db0e032532bbd959a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c98a8fd46c8b2ed4f003dd2bad0236"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ae8c98a8fd46c8b2ed4f003dd2bad0236">saturation</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ae8c98a8fd46c8b2ed4f003dd2bad0236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does saturation blending.  <a href="#ae8c98a8fd46c8b2ed4f003dd2bad0236">More...</a><br /></td></tr>
<tr class="separator:ae8c98a8fd46c8b2ed4f003dd2bad0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73ad11d25ab887b4a7eecb2f05b8e37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#ae73ad11d25ab887b4a7eecb2f05b8e37">color</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:ae73ad11d25ab887b4a7eecb2f05b8e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does color blending.  <a href="#ae73ad11d25ab887b4a7eecb2f05b8e37">More...</a><br /></td></tr>
<tr class="separator:ae73ad11d25ab887b4a7eecb2f05b8e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8d1176609738de46b2e6010e13c3d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1color__blend.html#a8b8d1176609738de46b2e6010e13c3d9">luminosity</a> (<a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *source, <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *destination, bool use_source_region=true, bool use_destination_region=true)</td></tr>
<tr class="memdesc:a8b8d1176609738de46b2e6010e13c3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that does luminosity blending.  <a href="#a8b8d1176609738de46b2e6010e13c3d9">More...</a><br /></td></tr>
<tr class="separator:a8b8d1176609738de46b2e6010e13c3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a81f21e89f6d7c626879b9fadfb47ab75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81f21e89f6d7c626879b9fadfb47ab75"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>dissolve_func</b> (float s, float d, float alpha_diff)</td></tr>
<tr class="separator:a81f21e89f6d7c626879b9fadfb47ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11f5459339ba5e3ce44aec50cb99339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa11f5459339ba5e3ce44aec50cb99339"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>multiply_func</b> (float s, float d)</td></tr>
<tr class="separator:aa11f5459339ba5e3ce44aec50cb99339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e9152be81a33d01f5d3f303c043d8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e9152be81a33d01f5d3f303c043d8a"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>screen_func</b> (float s, float d)</td></tr>
<tr class="separator:aa8e9152be81a33d01f5d3f303c043d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4af68007c66fd74b204705c54079d2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4af68007c66fd74b204705c54079d2a"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>overlay_func</b> (float s, float d)</td></tr>
<tr class="separator:aa4af68007c66fd74b204705c54079d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add64e58d8088607eeb6dbcf126d5c4c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add64e58d8088607eeb6dbcf126d5c4c5"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>darken_func</b> (float s, float d)</td></tr>
<tr class="separator:add64e58d8088607eeb6dbcf126d5c4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5eed59d6344e23d533d7402db6785b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d5eed59d6344e23d533d7402db6785b"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>lighten_func</b> (float s, float d)</td></tr>
<tr class="separator:a1d5eed59d6344e23d533d7402db6785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c4cf24f501152dd9799f783e29b5d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19c4cf24f501152dd9799f783e29b5d8"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>color_dodge_func</b> (float s, float d)</td></tr>
<tr class="separator:a19c4cf24f501152dd9799f783e29b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ebdcb3c8fe8f23436b8cbd4a44e6b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81ebdcb3c8fe8f23436b8cbd4a44e6b6"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>linear_dodge_func</b> (float s, float d)</td></tr>
<tr class="separator:a81ebdcb3c8fe8f23436b8cbd4a44e6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80912e406962954d1c831f77f01c5b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab80912e406962954d1c831f77f01c5b2"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>color_burn_func</b> (float s, float d)</td></tr>
<tr class="separator:ab80912e406962954d1c831f77f01c5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4568ddd2b3558dcd00e0a8df2c8c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b4568ddd2b3558dcd00e0a8df2c8c3"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>linear_burn_func</b> (float s, float d)</td></tr>
<tr class="separator:a43b4568ddd2b3558dcd00e0a8df2c8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f111c94f934d0840c1729c05788c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a232f111c94f934d0840c1729c05788c8"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>hard_light_func</b> (float s, float d)</td></tr>
<tr class="separator:a232f111c94f934d0840c1729c05788c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbc3e67edb1ec3a1884df617bac7dee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dbc3e67edb1ec3a1884df617bac7dee"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>soft_light_func</b> (float s, float d)</td></tr>
<tr class="separator:a5dbc3e67edb1ec3a1884df617bac7dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923cd01156cb97c0a317405da075d5ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a923cd01156cb97c0a317405da075d5ec"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>vivid_light_func</b> (float s, float d)</td></tr>
<tr class="separator:a923cd01156cb97c0a317405da075d5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74f59c14de2bd8919f32277909396ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af74f59c14de2bd8919f32277909396ab"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>linear_light_func</b> (float s, float d)</td></tr>
<tr class="separator:af74f59c14de2bd8919f32277909396ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e2b73cc668b18cb649cd19b3fd59c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70e2b73cc668b18cb649cd19b3fd59c7"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>pin_light_func</b> (float s, float d)</td></tr>
<tr class="separator:a70e2b73cc668b18cb649cd19b3fd59c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656e7e31842e24a0f0b9ab1b0c5b242f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a656e7e31842e24a0f0b9ab1b0c5b242f"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>hard_mix_func</b> (float s, float d)</td></tr>
<tr class="separator:a656e7e31842e24a0f0b9ab1b0c5b242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9988ff433fc37b2836753b307aa3bea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9988ff433fc37b2836753b307aa3bea"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>difference_func</b> (float s, float d)</td></tr>
<tr class="separator:af9988ff433fc37b2836753b307aa3bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d36fe77d22753fe6cfccf4f152ef88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38d36fe77d22753fe6cfccf4f152ef88"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>subtract_func</b> (float s, float d)</td></tr>
<tr class="separator:a38d36fe77d22753fe6cfccf4f152ef88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dab4fa3ac63543914cc41e19202c4ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dab4fa3ac63543914cc41e19202c4ea"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>divide_func</b> (float s, float d)</td></tr>
<tr class="separator:a0dab4fa3ac63543914cc41e19202c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784004c71b0ab2c929516445141527ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a784004c71b0ab2c929516445141527ea"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>plus_lighter_func</b> (float s, float d)</td></tr>
<tr class="separator:a784004c71b0ab2c929516445141527ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec353aa537e35a1a92b18b8925e4adeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec353aa537e35a1a92b18b8925e4adeb"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>plus_darker_func</b> (float s, float d)</td></tr>
<tr class="separator:aec353aa537e35a1a92b18b8925e4adeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab121856ffe7c74d4e4eb58bf4db2fdc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab121856ffe7c74d4e4eb58bf4db2fdc0"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>exclusion_func</b> (float s, float d)</td></tr>
<tr class="separator:ab121856ffe7c74d4e4eb58bf4db2fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classcolor__manipulation_1_1base__color__blend"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcolor__manipulation_1_1base__color__blend')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcolor__manipulation_1_1base__color__blend.html">color_manipulation::base_color_blend</a></td></tr>
<tr class="memitem:aac9d99d0c226f4dce33825cea1800f56 inherit pro_methods_classcolor__manipulation_1_1base__color__blend"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcolor__manipulation_1_1base__color__blend.html#aac9d99d0c226f4dce33825cea1800f56">general_porter_duff</a> (<a class="el" href="classcolor__space_1_1rgb__deepcolor.html">color_space::rgb_deepcolor</a> *source, <a class="el" href="classcolor__space_1_1rgb__deepcolor.html">color_space::rgb_deepcolor</a> *destination, bool use_s, bool use_d, bool use_b, std::function&lt; float(float, float)&gt; both_function)</td></tr>
<tr class="memdesc:aac9d99d0c226f4dce33825cea1800f56 inherit pro_methods_classcolor__manipulation_1_1base__color__blend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that actually does the combination of both colors by using a porter duff operator.  <a href="#aac9d99d0c226f4dce33825cea1800f56">More...</a><br /></td></tr>
<tr class="separator:aac9d99d0c226f4dce33825cea1800f56 inherit pro_methods_classcolor__manipulation_1_1base__color__blend"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Static class for color blending operations. </p>
<p>This static class implements 25 different color blending operations. </p>

<p>Definition at line <a class="el" href="color__blend_8h_source.html#l00018">18</a> of file <a class="el" href="color__blend_8h_source.html">color_blend.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae73ad11d25ab887b4a7eecb2f05b8e37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does color blending. </p>
<p>Static function that does color blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being color blended. Only source and only destination equals porter duffs' source respectively destination operators (plus color blending). Neither source and destination will produce something simular to porter duffs in operator with color blending. Note that this blend operator does not work componentwise but consider all components in a combination. Since the operation is done in hsl space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with color blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00459">459</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15e0177b913c296017f3db2719dc1f77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::color_burn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does color-burn blending. </p>
<p>Static function that does color-burn blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being color-dodge blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus color-burn blending). Neither source and destination will produce something simular to porter duffs in operator with color-burn blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with color-burn blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00173">173</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae8e94f8b4d42d595d7af4d780dee1a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::color_dodge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does color-dodge blending. </p>
<p>Static function that does color-dodge blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being color-dodge blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus color-dodge blending). Neither source and destination will produce something simular to porter duffs in operator with color-dodge blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with color-dodge blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00137">137</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eaff4ee01b1851b33d7e2b07ea3899d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::custom_componentwise_blend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float(float, float)&gt;&#160;</td>
          <td class="paramname"><em>blend_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does custom componentwise blending. </p>
<p>Static function that does custom componentwise blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being custom blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus custom blending). Neither source and destination will produce something simular to porter duffs in operator with custom blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">blend_function</td><td>The function that does the blending. It awaits source and destination components as input (in this order) and returns a blended float component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with custom blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00425">425</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6bd9bda0bf9739c66805d50a76284840"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::darken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does darken blending. </p>
<p>Static function that does darken blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being darken blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus darken blending). Neither source and destination will produce something simular to porter duffs in operator with darken blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with darken blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00101">101</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe333470ff1c136c26490ad83efa5365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does difference blending. </p>
<p>Static function that does difference blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being difference blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus difference blending). Neither source and destination will produce something simular to porter duffs in operator with difference blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with difference blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00317">317</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919ec14a652c1fef4e2e2429aa37b159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::dissolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does dissolve blending. </p>
<p>Static function that does dissolve blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being dissolve componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus dissolve). Neither source and destination will produce something simular to porter duffs in operator with dissolve. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with dissolve blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00022">22</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46ac01e6d28cbfdcf26e801df9e6610c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does divide blending. </p>
<p>Static function that does divide blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being divide blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus divide blending). Neither source and destination will produce something simular to porter duffs in operator with divide blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with divide blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00353">353</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a589516c17e3c9afc997f1307370792c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::exclusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does exclusion blending. </p>
<p>Static function that does exclusion blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being exclusion blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus exclusion blending). Neither source and destination will produce something simular to porter duffs in operator with exclusion blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with exclusion blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00407">407</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2e4a6dd31d114a086397053956716b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::hard_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does hard-light blending. </p>
<p>Static function that does hard-light blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being hard-light blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus hard-light blending). Neither source and destination will produce something simular to porter duffs in operator with hard-light blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with hard-light blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00209">209</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d581a4515405f43019fe363308e2cc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::hard_mix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does hard-mix blending. </p>
<p>Static function that does hard-mix blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being hard-mix blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus hard-mix blending). Neither source and destination will produce something simular to porter duffs in operator with hard-mix blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with hard-mix blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00299">299</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e1f8af32648db0e032532bbd959a554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::hue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does hue blending. </p>
<p>Static function that does hue blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being hue blended. Only source and only destination equals porter duffs' source respectively destination operators (plus hue blending). Neither source and destination will produce something simular to porter duffs in operator with hue blending. Note that this blend operator does not work componentwise but consider all components in a combination. Since the operation is done in hsl space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with hue blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00443">443</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4b3c39092194bcc71e30d73efa939b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::lighten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does lighten blending. </p>
<p>Static function that does lighten blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being lighten blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus lighten blending). Neither source and destination will produce something simular to porter duffs in operator with lighten blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with lighten blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00119">119</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6078f999bd634e3e0db79b4af441eea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::linear_burn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does linear-burn blending. </p>
<p>Static function that does linear-burn blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being linear-burn blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus linear-burn blending). Neither source and destination will produce something simular to porter duffs in operator with linear-burn blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with linear-burn blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00191">191</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac505037b69bd0b7e09b74006cfbdaed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::linear_dodge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does linear-dodge blending. </p>
<p>Static function that does linear-dodge blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being linear-dodge componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus linear-dodge). Neither source and destination will produce something simular to porter duffs in operator with linear-dodge. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with linear-dodge blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00155">155</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8dfd7cd6be99fd36dcc8d6ce1b7090d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::linear_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does linear-light blending. </p>
<p>Static function that does linear-light blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being linear-light blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus linear-light blending). Neither source and destination will produce something simular to porter duffs in operator with linear-light blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with linear-light blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00263">263</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b8d1176609738de46b2e6010e13c3d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::luminosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does luminosity blending. </p>
<p>Static function that does luminosity blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being luminosity blended. Only source and only destination equals porter duffs' source respectively destination operators (plus luminosity blending). Neither source and destination will produce something simular to porter duffs in operator with luminosity blending. Note that this blend operator does not work componentwise but consider all components in a combination. Since the operation is done in hsl space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with luminosity blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00467">467</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f9304fb70babc112300659602dbe1ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does multiply blending. </p>
<p>Static function that does multiply blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being multiplied componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus multiply). Neither source and destination will produce something simular to porter duffs in operator with multiply. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with multiply blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00041">41</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af44f0276259e2fdbe06c0a469e2302de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does not do any special blending. </p>
<p>Static function that does not do any special blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator. Only source and only destination equals porter duffs' source respectively destination operators. Neither source and destination will produce something simular to porter duffs in operator. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with normal blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00004">4</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa877bf0c850872e3128f6c479e888918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::overlay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does overlay blending. </p>
<p>Static function that does overlay blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being overlay blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus overlay blending). Neither source and destination will produce something simular to porter duffs in operator with overlay blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with overlay blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00080">80</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc3d505a4a31fca426862df5738c87fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::pin_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does pin-light blending. </p>
<p>Static function that does pin-light blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being pin-light blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus pin-light blending). Neither source and destination will produce something simular to porter duffs in operator with pin-light blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with pin-light blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00281">281</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3db631406f014046a89d9c83553847d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::plus_darker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does plus-darker blending. </p>
<p>Static function that does plus-darker blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being plus-darker blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus plus-darker blending). Neither source and destination will produce something simular to porter duffs in operator with plus-darker blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with plus-darker blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00389">389</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ad5bc17a16d0e73ef02a4d2306f22a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::plus_lighter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does plus-lighter blending. </p>
<p>Static function that does plus-lighter blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being plus-lighter blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus plus-lighter blending). Neither source and destination will produce something simular to porter duffs in operator with plus-lighter blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with plus-lighter blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00371">371</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8c98a8fd46c8b2ed4f003dd2bad0236"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::saturation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does saturation blending. </p>
<p>Static function that does saturation blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being saturation blended. Only source and only destination equals porter duffs' source respectively destination operators (plus saturation blending). Neither source and destination will produce something simular to porter duffs in operator with saturation blending. Note that this blend operator does not work componentwise but consider all components in a combination. Since the operation is done in hsl space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with saturation blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00451">451</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad07bf8b0fd82a59a8353f3828892f2fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::screen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does screen blending. </p>
<p>Static function that does screen blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being screen blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus screen blending). Neither source and destination will produce something simular to porter duffs in operator with screen blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with screen blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00059">59</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc528425b9f8038d86d38b3eb2e4f2d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::soft_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does soft-light blending. </p>
<p>Static function that does soft-light blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being soft-light blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus soft-light blending). Neither source and destination will produce something simular to porter duffs in operator with soft-light blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with soft-light blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00227">227</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d70c77cd299b53b76b47436b3bb5196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does subtract blending. </p>
<p>Static function that does subtract blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being subtract blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus subtract blending). Neither source and destination will produce something simular to porter duffs in operator with subtract blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with subtract blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00335">335</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c13bc67f915a7824e9a324a759cd7d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> * color_manipulation::color_blend::vivid_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolor__space_1_1color__base.html">color_space::color_base</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_source_region</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_destination_region</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that does vivid light blending. </p>
<p>Static function that does vivid light blending. In its default configuration (use source and destination region) it will produce the same result like the porter duff over operator with the overlapping area being vivid light blended componentwise. Only source and only destination equals porter duffs' source respectively destination operators (plus vivid light blending). Neither source and destination will produce something simular to porter duffs in operator with vivid light blending. Since the operation is done in rgb deep color space a conversion will be done first. Therefore source and destination do not need to have the same color type. However the rgb color space definitions of both colors must match. The resulting color will be in the same space like source color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source color of the operation. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination color of the operation. </td></tr>
    <tr><td class="paramname">use_source_region</td><td>Whether the source region of the resulting pixel will be blank or not. </td></tr>
    <tr><td class="paramname">use_destination_region</td><td>Whether the destination region of the resulting pixel will be blank or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of source and destination calculated with lighten blending. </dd></dl>

<p>Definition at line <a class="el" href="color__blend_8cpp_source.html#l00245">245</a> of file <a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ColorMagic/manipulation/<a class="el" href="color__blend_8h_source.html">color_blend.h</a></li>
<li>ColorMagic/manipulation/<a class="el" href="color__blend_8cpp_source.html">color_blend.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
